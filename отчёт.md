# Отчёт, Калабай Михаил Иванович БПИ219
## Работа претендует на 8 баллов, Вариант 20

20. Задача о программистах. В отделе работают три программиста. Каждый
программист пишет свою программу и отдает ее на проверку другому случайному программисту. Программист проверяет чужую программу, когда его
собственная уже написана и передана на проверку. По завершении проверки,
программист возвращает программу с результатом (формируемым случайно
по любому из выбранных Вами законов): программа написана правильно или
неправильно. Программист спит, если отправил свою программу и не проверяет чужую программу. Программист просыпается, когда получает заключение от другого программиста. Если программа признана правильной, программист пишет другую программу, если программа признана неправильной,
программист исправляет ее и отправляет на проверку тому же программисту,
который ее проверял. К исправлению своей программы он приступает, завершив проверку чужой программы. При наличии в очереди проверяемых программ и приходе заключения о неправильной своей программы программист
может выбирать любую из возможных работ. Создать многопоточное приложение, моделирующее работу программистов.

## Интерпретация условий

Есть 3 программисты и n задач, которые они должны решить, n вводит пользователь. Задачи пронумерованы от 1 до n. Изначально у каждого программиста нет ни одной задачи для того, чтобы они могли справляться со случаями, где n < 3.
Если программист свободен, то есть не проверяет задачу или не ждёт ответа на проверку, тогда он начинает решать невыбранную никем задачу с наименьшим номером.
Когда программист дописал задачу и отправил на проверку другому, то он смотрит, есть ли у него, что нужно проверить. Если есть, то проверяет. После проверки и прихода результата задачи программист либо работает над старой задачей в случае неудачи, либо берёт новую.
Процесс заканчивается, когда ни один программист не может взять новую задачу.

### Про входные данные

n может быть любым целым числом (помещающемся в int), если n <= 0, то программисты справились с задачами ничего по сути не делая. Чем больше задач, тем дольше будет работать. На решение одной задачи может уходить +- 10 секунд (учитывая неудачи при написании и проверки). Так что большие n лучше не вводить, хотя такая возможность есть, и это не вызовет проблем у программы.

### Про многопоточку

Три программиста = три потока, функция у них одинаковая, программисты отличаются только номером (и он параметр функции). Модель взаимодействующие равные, так как потоки взаимодействуют только с друг другом (черпая информацию из общего массива). Похожа на портфель задач, потому что поток получает задачу из очереди (портфеля) и решает её до момента выполнения, потом снова берёт задачу из очереди (портфеля).
Общий массив просто хранит в себе информацию о результате проверки, где result[i][j] - результат проверки кода программиста i программистом j. -2 - требуется проверка; -1 - ничего; 0 - неудача; 1 - успех, код верен.
А также присутствуют мьютексы для синхронизации работы потоков. Есть мьютекс для корректного вывода, есть мьютекс для корректной работы с очередью задач (портфелем задач), чтобы два потока случайно не пытались взаимодействовать с одним и тем же элементом. И есть три мьютекса по одному для каждого программиста. Они нужны для "сна" программистов, которые написали задачу, проверили чужие и ожидают проверки своего кода.
Например программист 1 ждёт проверку от 3, и нужно поймать момент, когда 3 сделает это. Для этого 1 "упирается" в мьютекс 3. И пока 3 не сделает все свои дела, проверка не начнётся. И после того, как 3 освободится, то он сможет начать проверку, в момент которой мьютекс снова lock (потому что иначе 3 будет свободен и начнёт решать следующую задачу параллельно с проверкой, чего быть в реальности не может). После проверки снова unlock, и 1 смотрит на результат проверки.
И поток main для считывания и создания остальных потоков. Написание кода представляет из себя sleep на рандомное число секунд от 1 до 5, аналогично проверка от 1 до 2. Попытка починить неудачную задачу тоже от 1 до 5. Вероятность удачи/неудачи 50/50.

Вкратце c "не то, как это будет реализовано в программе": Программист берёт задачу, если есть, решает и отправляет на проверку. Пока ждёт проверку, проверяет чужие, если ему прислали. Далее спит, пока не узнает фидбек по решению от другого программиста. Получает результат, и либо его ждёт новая задача (при успехе), либо повтор всего с момента "решает". И так пока программистам есть, что надо решать.

Про метод читал здесь https://pro-prof.com/forums/topic/parallel-programming-paradigms

### Пример происходящего при 3 задачах

![Build Status](https://github.com/Kalabay/AVS_IHW04/blob/main/images/example.png)

### Программа на языке C++

Программа написана на языке C++, (см. файл [main.cpp](https://github.com/Kalabay/AVS_IHW04/blob/main/HW04/main.cpp)). \
Так же есть комментарии, описывающие функционал. 

### Про режимы ввода на 6, 7, 8

При любом режиме ввода я вывожу результат в том числе и в консоль. \
Чтобы ввести из командной строки, нужно просто передать одно число = n, пример:\
![Build Status](https://github.com/Kalabay/AVS_IHW04/blob/main/images/c.png)\
Файловый ввод вывод выглядит, как ввод в консоль f, а затем сами файлы (пример для файла с n = 2):\
![Build Status](https://github.com/Kalabay/AVS_IHW04/blob/main/images/f.png)\
Генерация есть в двух вариантах, просто g = только обычный вывод, g + выходной файл запишет результат ещё и в файл. При генерации n только от 0 до 20, чтобы особо долго не ждать:\
![Build Status](https://github.com/Kalabay/AVS_IHW04/blob/main/images/g1.png)\
![Build Status](https://github.com/Kalabay/AVS_IHW04/blob/main/images/g2.png)


### Входные и выходные файлы с различными результатами выполнения программы
Тесты лежат тут [tests](https://github.com/Kalabay/AVS_IHW04/tree/main/tests)\
в этих тестах все n $\in$ [0, 4]
