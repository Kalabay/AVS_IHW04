# Отчёт, Калабай Михаил Иванович БПИ219
## Работа претендует на 8 баллов, Вариант 20

20. Задача о программистах. В отделе работают три программиста. Каждый
программист пишет свою программу и отдает ее на проверку другому случайному программисту. Программист проверяет чужую программу, когда его
собственная уже написана и передана на проверку. По завершении проверки,
программист возвращает программу с результатом (формируемым случайно
по любому из выбранных Вами законов): программа написана правильно или
неправильно. Программист спит, если отправил свою программу и не проверяет чужую программу. Программист просыпается, когда получает заключение от другого программиста. Если программа признана правильной, программист пишет другую программу, если программа признана неправильной,
программист исправляет ее и отправляет на проверку тому же программисту,
который ее проверял. К исправлению своей программы он приступает, завершив проверку чужой программы. При наличии в очереди проверяемых программ и приходе заключения о неправильной своей программы программист
может выбирать любую из возможных работ. Создать многопоточное приложение, моделирующее работу программистов.

## Интерпретация условий

Есть 3 программисты и n задач, которые они должны решить, n вводит пользователь. Задачи пронумерованны от 1 до n. Изначально у каждого программиста нет ни одной задачи. 
Если программист свободен, то есть не проверяет задачу или не ждёт ответа на проверку, тогда он начинает решать невыбранную никем задачу с наименьшим номером.
Когда программист дописал задачу и отправил на проверку другому, то он смотрит, есть ли у него, что нужно проверить. Если есть, то проверяет. После проверки и прихода результата задачи программист либо работает над старой задачей в случае неудачи, либо берёт новую.
Процесс заканичвается, когда ни один программист не может взять новую задачу.

### Про входные данные

n может быть любым целым числом (помещающемся в int), если n <= 0, то программисты справились с задачами ничего по сути не делая. Чем больше задач, тем дольше будет работать. На решение одной задачи может уходить +- 10 секунд (учитывая неудачи при написании и проверки). Так что большие n лучше не вводить, хотя такая возможность есть и это не вызовет проблем у программы.

### Про многопоточку

Три программиста = три потока, функция у них одинаковая, программисты отличаются только номером (и он параметр функции). Модель взаимодействующие равные, так как потоки взаимодействуют только с друг другом (черпая информацию из общегое массива). Похожа на портфель задач, потому что поток получает задачу из очереди (портфеля) и решает её до момента выполнения, потом снова берёт задачу из очереди (портфеля).
Общий массив просто хранит в себе информацию о результате проверки, где result[i][j] - результат проверки кода программиста i программистом j. -2 - требуется проверка; -1 - ничего; 0 - неудача; 1 - успех, код верен.
А также присутствуют мьютексы для синхронизации работы потоков. Есть мьютекс для корректного вывода, есть мьютекс для корректной работы с очередью задач (портфелем задач), чтобы два потока случайно не пытались взаимодействовать с одним и тем же элементом. И есть три мьютекса по одному для каждого программиста. Они нужные для "сна" программистов, которые написали задачу, проверили чужие и ожидают проверки своего кода.
Например программист 1 ждёт проверку от 3, и нужно поймать момент, когда 3 сделает это. Для этого 1 "упирается" в мьютекс 3. И пока 3 не сделает все свои дела, проверка не начнётся. И после того, как 3 освободится, то он сможет начать проверку, в момент которой мьютекс снова lock (потому что иначе 3 будет свободен и начнёт решать следующую задачу параллельно с проверкой, чего быть в реальности не может). После проверки снова unlock, и 1 смотрит на результат проверки.
И поток main для считывания и создания остальных потоков.

### Программа на языке C++

Программа написана на языке C, использует локальные переменные и функции (см. файл [arcsin.c](https://github.com/Kalabay/AVS_IHW03/blob/main/arcsin.c)). \
Так же есть комментарии, описывающие функционал. 

### Затем воспользуемся терминалом

gcc [arcsin.c](https://github.com/Kalabay/AVS_IHW03/blob/main/arcsin.c) -S -o [arcsinBad.s](https://github.com/Kalabay/AVS_IHW03/blob/main/arcsinBad.s)

### Потом убираем лишнее

gcc -masm=intel -fno-asynchronous-unwind-tables -fno-jump-tables -fno-stack-protector -fno-exceptions [arcsin.c](https://github.com/Kalabay/AVS_IHW03/blob/main/arcsin.c) -S -o [arcsin.s](https://github.com/Kalabay/AVS_IHW03/blob/main/arcsin.s)
Практически каждая строчка этого кода была прокомментирована и были проведены параллели с перемеными кода на С (см. файл [arcsin.s](https://github.com/Kalabay/AVS_IHW03/blob/main/arcsin.s))

### Теперь про тестирование

Картинки всех версий для первого и второго теста: 

![Build Status](https://github.com/Kalabay/AVS_IHW03/blob/main/images/w1.png)
![Build Status](https://github.com/Kalabay/AVS_IHW03/blob/main/images/w2.png)
![Build Status](https://github.com/Kalabay/AVS_IHW03/blob/main/images/p1.png)
![Build Status](https://github.com/Kalabay/AVS_IHW03/blob/main/images/p2.png)
![Build Status](https://github.com/Kalabay/AVS_IHW03/blob/main/images/p3.png)
![Build Status](https://github.com/Kalabay/AVS_IHW03/blob/main/images/p4.png)

Эти и остальные тесты доступны в папке tests (.in -> сам тест, .out -> правильный ответ на тест). 

### Работа с регистрами на 6

Первое, что я сделал, это убрал со стека n в функции подсчёта факториала (см [arcsinBest.s](https://github.com/Kalabay/AVS_IHW03/blob/main/arcsinBest.s)).\
Фото части кода, где это видно (выделенное = что было до изменения):\
![Build Status](https://github.com/Kalabay/AVS_IHW03/blob/main/images/r1.jpg)
А также заменил n в остальных местах этой функции

Затем индекс в цикле (см [arcsinBest.s](https://github.com/Kalabay/AVS_IHW03/blob/main/arcsinBest.s)).\
Фото части кода, где это видно (выделенное = что было до изменения):\
![Build Status](https://github.com/Kalabay/AVS_IHW03/blob/main/images/r2.png)

Аналогично стал хранить fact (xmm11) (см [arcsinBest.s](https://github.com/Kalabay/AVS_IHW03/blob/main/arcsinBest.s)).

А также аналогичные действия были проделаны в Arcsin для всех переменных (x, arcsin, n, four, add, xNow, POS_INF и т.д.), что позволило убрать sub rsp, 80 (см [arcsinBest.s](https://github.com/Kalabay/AVS_IHW03/blob/main/arcsinBest.s)).\
<img width="182" alt="image" src="https://user-images.githubusercontent.com/90344366/204154412-c5111112-17bd-4858-be7f-e4d3b9bbc60c.png">

Тестирование на тех же двух тестах:\
![Build Status](https://github.com/Kalabay/AVS_IHW03/blob/main/images/end.png)
